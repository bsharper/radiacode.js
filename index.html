<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>RadiaCode.js Demo</title>
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
<script src="https://cdn.jsdelivr.net/npm/vue-apexcharts"></script>
<script src="smoothie.js"></script>
<script src="radiacode.js"></script>

</head>
<link rel="stylesheet" href="css/fontello.css">
<link rel="stylesheet" href="css/animation.css">
<link rel="stylesheet" href="css/main.css">
<style>
/* Min/Max pill styling (updated neutral theme) */
.minmax-pill{display:inline-flex;align-items:stretch;border:1px solid #d0d7de;background:#fff;border-radius:14px;overflow:hidden;font-size:11px;font-weight:500;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,sans-serif;margin-top:4px;color:#555;}
.minmax-pill span{padding:2px 8px;display:inline-block;line-height:1.2;white-space:nowrap;}
.minmax-pill span+span{border-left:1px solid #d0d7de;}
.minmax-pill .pill-min,.minmax-pill .pill-max{color:#555;background:transparent;}
.realtime-item .minmax-pill{margin-top:6px;}
.value .unit-inline{margin-left:6px;font-size:0.65em;font-weight:600;color:#555;letter-spacing:.5px;vertical-align:middle;}
</style>
<body>
<div id="app">
  <!-- Connection Controls -->
  <div class="connection-controls">
    <h3>Device Connection</h3>
    <div class="connection-row">
      <div class="connection-buttons">
        <button 
          class="connection-button connect-bluetooth" 
          @click="connectBluetooth" 
          :disabled="isConnected || isConnecting">
          <i class="icon-bluetooth-b"></i>Connect Bluetooth
        </button>
        <button 
          class="connection-button connect-usb" 
          @click="connectUSB" 
          :disabled="isConnected || isConnecting">
          <i class="icon-usb"></i> Connect USB
        </button>
        <button 
          class="connection-button disconnect" 
          @click="disconnect" 
          :disabled="!isConnected">
          üîå Disconnect
        </button>
        <button 
          class="connection-button auto-update" 
          @click="toggleAutoUpdate" 
          :disabled="!isConnected">
          Auto-update: {{ autoUpdateEnabled ? "ON" : "OFF" }}
        </button>
        <button 
          class="connection-button alarm-settings" 
          @click="loadAlarmSettings" 
          :disabled="!isConnected">
          Show Alarm Settings
        </button>
      </div>
      
      <div :class="['status', connectionStatus.toLowerCase()]">
        {{ connectionStatusText }}
        <span v-if="isConnected && autoUpdateEnabled" style="margin-left: 10px; font-size: 0.9em;">({{ updateInterval/1000 }}s interval)</span>
      </div>
    </div>
    
    <div class="log-section" v-if="logMessages.length > 0">
      <div class="log-header" @click="toggleLogExpanded">
        <div class="log-header-left">
          <span class="log-toggle-icon">{{ logExpanded ? '‚ñº' : '‚ñ∂' }}</span>
          <span>Activity Log ({{ logMessages.length }} messages)</span>
          <span v-if="logExpanded && !logAutoScroll" class="auto-scroll-indicator">Scroll paused</span>
        </div>
        <button @click.stop="clearLog" class="clear-log-button">Clear</button>
      </div>
      <div class="log" v-show="logExpanded" ref="logContainer" @scroll.passive="handleLogScroll">
        <div v-for="msg in visibleLogMessages" :key="msg.id" class="log-entry">
          <span class="log-timestamp">{{ msg.timestamp }}</span> 
          <span class="log-message">{{ msg.message }}</span>
        </div>
        <div v-if="logMessages.length > maxVisibleMessages" class="log-entry log-info">
          ... {{ logMessages.length - maxVisibleMessages }} earlier messages (scroll to top to load)
        </div>
      </div>
    </div>
  </div>

  <!-- Device Information -->
  <div class="device-info" v-if="isConnected">
    <h3>Device Information</h3>
    <div class="device-info-grid">
      <div class="device-info-item">
        <label>Serial Number:</label>
        <span>{{ deviceInfo.serialNumber || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Firmware Version:</label>
        <span>{{ deviceInfo.firmwareVersion || 'Loading...' }}</span>
      </div>
      <div class="device-info-item">
        <label>Connection Type:</label>
        <span>{{ deviceInfo.connectionType || 'Unknown' }}</span>
      </div>
      <div class="device-info-item">
        <label>Last Update:</label>
        <span>{{ deviceInfo.lastUpdate || 'Never' }}</span>
      </div>
    </div>
  </div>
  
  <!-- Alarm Limits -->
  <div class="alarm-limits" v-if="isConnected && alarmLimits">
    <h3>Alarm Limits</h3>
    <div class="alarm-limits-grid">
      <div class="alarm-item">
        <label>Count Rate L1/L2:</label>
        <span>{{ alarmLimits.l1_count_rate.toFixed(1) }} / {{ alarmLimits.l2_count_rate.toFixed(1) }} {{ alarmLimits.count_unit }}</span>
      </div>
      <div class="alarm-item">
        <label>Dose Rate L1/L2:</label>
        <span>{{ alarmLimits.l1_dose_rate.toFixed(1) }} / {{ alarmLimits.l2_dose_rate.toFixed(1) }} ¬µ{{ alarmLimits.dose_unit }}/h</span>
      </div>
      <div class="alarm-item">
        <label>Dose L1/L2:</label>
        <span>{{ alarmLimits.l1_dose.toFixed(1) }} / {{ alarmLimits.l2_dose.toFixed(1) }} ¬µ{{ alarmLimits.dose_unit }}</span>
      </div>
    </div>
  </div>

  <!-- Real-time Data -->
  <div class="realtime-data" v-if="isConnected">
    <h3>Real-time Data</h3>
    <div class="realtime-grid">
      <div class="realtime-item">
        <div class="label">Count Rate</div>
        <span class="value">
          {{ currentData.countRate.toFixed(2) }}
          <span class="unit-inline">CPS</span>
          <span class="error">¬± {{ currentData.countRateError.toFixed(2) }}</span>
        </span>
        <div class="minmax-pill">
          <span class="pill-min">Min {{ stats.countRate.min == null ? '-' : stats.countRate.min.toFixed(2) }}</span>
          <span class="pill-max">Max {{ stats.countRate.max == null ? '-' : stats.countRate.max.toFixed(2) }}</span>
        </div>
      </div>
      <div class="realtime-item">
        <div class="label">Dose Rate</div>
        <span class="value">
          {{ currentData.doseRate.toFixed(4) }}
          <span class="unit-inline">¬µSv/h</span>
          <span class="error">¬± {{ currentData.doseRateError.toFixed(4) }}</span>
        </span>
        <div class="minmax-pill">
          <span class="pill-min">Min {{ stats.doseRate.min == null ? '-' : stats.doseRate.min.toFixed(4) }}</span>
          <span class="pill-max">Max {{ stats.doseRate.max == null ? '-' : stats.doseRate.max.toFixed(4) }}</span>
        </div>
      </div>
    </div>
    <div class="realtime-grid">
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Count Rate (CPS)</h4>
        <canvas id="countRateChart"></canvas>
      </div>
      <div class="chart-container">
        <h4 style="margin-top: 0; color: #155724;">Dose Rate (¬µSv/h)</h4>
        <canvas id="doseRateChart"></canvas>
      </div>
    </div>
  </div>

  <!-- Spectrum Chart -->
  <div>
    <apexchart type="bar" height="350" :options="spectrumChartOptions" :series="spectrum_series"></apexchart>
    <div>
      <fieldset>
        <input type="checkbox" id="spectrum_x_accum" v-model="spectrum_accum">
        <label for="spectrum_x_accum">Accumulated</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_x_channel" v-bind:value="false" v-model="spectrum_energy">
        <label for="spectrum_x_channel">Channel</label>

        <input type="radio" id="spectrum_x_energy" v-bind:value="true" v-model="spectrum_energy">
        <label for="spectrum_x_energy">Energy</label>
      </fieldset>
      <fieldset>
        <input type="radio" id="spectrum_linear" v-bind:value="false" v-model="spectrum_logarithmic">
        <label for="spectrum_linear">Linear</label>
        <input type="radio" id="spectrum_log" v-bind:value="true" v-model="spectrum_logarithmic">
        <label for="spectrum_log">Logarithmic</label>
      </fieldset>
    </div>
    <button @click="updateSpectrum" :disabled="!isConnected">Update spectrum</button>
    <button @click="resetSpectrum" :disabled="!isConnected">Reset spectrum</button>
  </div>

  <!-- Rates Chart -->
  <div>
    <apexchart type="line" height="350" :options="ratesChartOptions" :series="rates_series"></apexchart>
    <div>
      <button @click="clearRatesData">Clear Rates Data</button>
      <span v-if="rates_series.length > 0">
        Data points: {{ rates_series[0]?.data?.length || 0 }}
      </span>
    </div>
  </div>

  <!-- Recording / Storage Section -->
  <div class="storage-section" v-if="isConnected">
    <h3>Recording</h3>
    <div>
      Samples stored: {{ storage.totalSamples }}
      <span v-if="storage.sizeBytes"> (~{{ (storage.sizeBytes/1024).toFixed(1) }} KB)</span>
      <span v-if="storage.buffer.length"> | Buffer: {{ storage.buffer.length }}</span>
      <span v-if="!storage.enabled" style="color:#c00; margin-left:8px;">(Paused)</span>
    </div>
    <div style="margin-top:6px; display:flex; gap:8px; flex-wrap:wrap;">
      <button @click="toggleStorage">{{ storage.enabled ? 'Pause Recording' : 'Resume Recording' }}</button>
      <button @click="exportStoredSamples" :disabled="!storage.totalSamples">Export JSON</button>
      <button @click="clearStoredSamples" :disabled="!storage.totalSamples">Clear Stored</button>
    </div>
  </div>
</div>

<footer style="margin-top: 24px; padding: 12px 16px; color:#666; font-size: 12px; border-top: 1px solid #eee;">
  RadiaCode.js <span id="lib-version">v?</span>
  <span style="margin-left:8px; color:#aaa;">‚Äî Demo UI</span>
  <span style="float:right; color:#aaa;">Firmware info appears after connect</span>
  <div style="clear:both"></div>
  <script>
    // Display library version in footer if available
    (function(){
      try {
        var el = document.getElementById('lib-version');
        var v = (window.RadiaCode && window.RadiaCode.VERSION) || window.RadiaCodeJS_VERSION;
        if (el && v) el.textContent = 'v' + v;
      } catch (_) {}
    })();
  </script>
  
</footer>

<script>
const common_options = {
  chart: {
    animations: {enabled: false},
    zoom: {autoScaleYaxis: true},
  },
  tooltip: {intersect: false},
  grid: {xaxis: {lines: {show: true}}},
  dataLabels: {enabled: false},
};

var app = new Vue({
  el: '#app',
  components: {
    apexchart: VueApexCharts,
  },
  data: function() {
    return {
      device: null,
      isConnected: false,
      isConnecting: false,
      connectionStatus: 'Disconnected',
      connectionStatusText: 'Not connected to device',
      
      // Device information
      deviceInfo: {
        firmwareVersion: null,
        serialNumber: null,
        connectionType: null,
        lastUpdate: null
      },
      
      // Alarm limits
      alarmLimits: null,
      
      // Real-time data
      currentData: {
        countRate: 0,
        doseRate: 0,
        countRateError: 0,
        doseRateError: 0
      },
      
      // Smoothie chart
      countRateChart: null,
      doseRateChart: null,
      countRateTimeSeries: null,
      doseRateTimeSeries: null,
      
      // Auto-update functionality
      autoUpdateEnabled: false,
      updateInterval: 1000, // 500ms
      updateTimer: null,
      realTimeDataMessages: 0,
      realTimeDataMessagesMax: 5,
      
      // Logging
      logMessages: [],
      logCounter: 0,
      logExpanded: true, // Start expanded by default
      maxVisibleMessages: 500, // Limit DOM elements for performance
      logAutoScroll: true, // Whether to auto-scroll to bottom on new messages
      
      // Spectrum data
      spectrum_duration: 0,
      spectrum_series: [],
      spectrum_coef: [0, 0, 0],
      spectrum_accum: false,
      spectrum_logarithmic: true,
      spectrum_energy: true,
      
      // Rates data
      rates_series: [
        {name: 'Count Rate', data: [], yAxisIndex: 0},
        {name: 'Dose Rate', data: [], yAxisIndex: 1}
      ],
      
      // Real-time min/max stats
      stats: {
        countRate: {min: null, max: null},
        doseRate: {min: null, max: null},
      },
      
      // Persistent storage for realtime samples
      storage: {
        enabled: true,
        key: 'radiacode_realtime_v1',
        buffer: [],
        lastFlush: 0,
        flushInterval: 10000, // ms
        maxBufferSize: 100,   // flush when exceeded
        maxSamples: 200000,   // prune oldest beyond this
        totalSamples: 0,
        sizeBytes: 0,
      },
      
      ratesChartOptions: {
        ...common_options,
        title: {text: 'CountRate & DoseRate'},
        xaxis: {type: 'datetime'},
        yaxis: [
          {seriesName: 'countrate', title: {text: 'CPS'}, labels: {formatter:(v) => v.toFixed(2) + ' CPS'}},
          {seriesName: 'doserate',  title: {text: 'ŒºSv/h'}, labels: {formatter:(v) => v.toFixed(6) + ' ŒºSv/h'}, opposite: true},
        ],
      },
    }; // end return
  }, // end data
  watch: {
    spectrum_accum() {
      if (this.isConnected) {
        this.updateSpectrum();
      }
    }
  },
  computed: {
    visibleLogMessages() {
      // Show the most recent messages for performance
      if (this.logMessages.length <= this.maxVisibleMessages) {
        return this.logMessages;
      }
      return this.logMessages.slice(-this.maxVisibleMessages);
    },
    spectrumChartOptions() {
      const a0 = this.spectrum_coef[0], a1 = this.spectrum_coef[1], a2 = this.spectrum_coef[2];
      const fmt = this.spectrum_energy ? ((c) => (a0 + a1*c + a2*c*c).toFixed(0)) : undefined;
      const title = this.spectrum_energy ? 'keV' : 'channel';
      return{
        ...common_options,
        title: {text: `Spectrum, ${this.spectrum_duration} seconds`},
        xaxis: {type: 'numeric', title: {text: title}, tickAmount: 25, labels: {formatter:fmt}},
        yaxis: {logarithmic: this.spectrum_logarithmic, decimalsInFloat: 0},
        plotOptions: {bar: {columnWidth: '95%'}},
      };
    },
  },
  created() {
  this.log('RadiaCode Standalone Demo initialized');
  const v = (window.RadiaCode && window.RadiaCode.VERSION) || window.RadiaCodeJS_VERSION;
  if (v) this.log(`Library version: v${v}`);
    this.log('Connect to your device using Bluetooth or USB');
    this.loadStoredSamples();
    window.addEventListener('beforeunload', this.beforeUnloadHandler);
  },
  beforeDestroy: function() {
    if (this.updateTimer) {
      clearInterval(this.updateTimer);
    }
    if (this.device && this.isConnected) {
      this.device.disconnect();
    }
    this.flushStorage(true);
    window.removeEventListener('beforeunload', this.beforeUnloadHandler);
  },
  methods: {
    log(message) {
      const timestamp = new Date().toLocaleTimeString();
      this.logMessages.push({
        id: this.logCounter++,
        timestamp,
        message
      });
      
      // Auto-scroll to bottom only if user is already at the bottom and log is expanded
      this.$nextTick(() => {
        if (this.logExpanded && this.logAutoScroll) {
          const logEl = document.querySelector('.log');
          if (logEl) {
            logEl.scrollTop = logEl.scrollHeight;
          }
        }
      });
    },

    handleLogScroll() {
      const logEl = this.$refs.logContainer;
      if (logEl) {
        // Check if user is at the bottom (within 5px tolerance)
        const isAtBottom = logEl.scrollHeight - logEl.scrollTop - logEl.clientHeight < 5;
        this.logAutoScroll = isAtBottom;
      }
    },

    toggleLogExpanded() {
      this.logExpanded = !this.logExpanded;
      
      // Auto-scroll to bottom when expanding (and reset auto-scroll to true)
      if (this.logExpanded) {
        this.logAutoScroll = true;
        this.$nextTick(() => {
          const logEl = document.querySelector('.log');
          if (logEl) {
            logEl.scrollTop = logEl.scrollHeight;
          }
        });
      }
    },

    clearLog() {
      this.logMessages = [];
      this.logCounter = 0;
      this.logAutoScroll = true; // Reset auto-scroll when clearing
      this.log('Log cleared');
    },

    beforeUnloadHandler() { this.flushStorage(true); },

    async connectBluetooth() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via Bluetooth...';
        this.log('Attempting Bluetooth connection...');
        
        this.device = new RadiaCode(null, true); // Request Bluetooth
        window.device = this.device; // For debugging
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via Bluetooth';
        this.deviceInfo.connectionType = 'Bluetooth';
        this.log('‚úÖ Connected successfully via Bluetooth');
        window.device = this.device; // For debugging
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`‚ùå Bluetooth connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async connectUSB() {
      try {
        this.isConnecting = true;
        this.connectionStatus = 'Connecting';
        this.connectionStatusText = 'Connecting via USB...';
        this.log('Attempting USB connection...');
        
        if (!RadiaCodeUSBTransport.isSupported()) {
          throw new Error('Web USB is not supported in this browser');
        }
        
        this.device = new RadiaCode();
        window.device = this.device; 
        await this.device.connect();
        
        this.isConnected = true;
        this.connectionStatus = 'Connected';
        this.connectionStatusText = 'Connected via USB';
        this.deviceInfo.connectionType = 'USB';
        this.log('‚úÖ Connected successfully via USB');
        
        await this.initializeDevice();
        
      } catch (error) {
        this.log(`‚ùå USB connection failed: ${error.message}`);
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = `Connection failed: ${error.message}`;
        this.device = null;
      } finally {
        this.isConnecting = false;
      }
    },

    async initializeDevice() {
      try {
        this.realTimeDataMessages = 0;
        this.log('Getting firmware version...');
        const version = await this.device.getFirmwareVersion();
        this.deviceInfo.firmwareVersion = `v${version.target.major}.${version.target.minor}`;
        this.log(`Firmware: ${this.deviceInfo.firmwareVersion}`);
        
        this.log('Getting serial number...');
        const serial = await this.device.getSerialNumber();
        this.deviceInfo.serialNumber = serial;
        this.log(`Device: ${serial}`);
        
        this.log('Getting alarm limits...');

        //this.alarmLimits = await this.device.getAlarmLimits(); 
        // this.log(`Alarm limits: CR L1/L2=${this.alarmLimits.l1_count_rate}/${this.alarmLimits.l2_count_rate} ${this.alarmLimits.count_unit}, DR L1/L2=${this.alarmLimits.l1_dose_rate}/${this.alarmLimits.l2_dose_rate} ¬µ${this.alarmLimits.dose_unit}/h`);
        
        // Test data buffer to see what we get
        // this.log('Testing initial data buffer...');
        // const testData = await this.device.data_buf();
        // this.log(`Got ${testData.length} records from data buffer`);
        
        // for (let i = 0; i < Math.min(3, testData.length); i++) {
        //   const record = testData[i];
        //   if (record instanceof RealTimeData) {
        //     this.log(`Sample data[${i}]: CR=${record.count_rate}, DR=${record.dose_rate}, CR_err=${record.count_rate_err}, DR_err=${record.dose_rate_err}`);
        //   } else {
        //     this.log(`Sample data[${i}]: ${record.constructor.name}`);
        //   }
        // }
        
        // Get initial spectrum
        this.log('Getting initial spectrum...');
        await this.updateSpectrum();
        
        // Start auto-update by default
        this.toggleAutoUpdate();
        
        // Initialize smoothie chart
        this.initializeSmoothieChart();
        
        this.log('‚úÖ Device initialization completed successfully');
        
      } catch (error) {
        this.log(`‚ùå Device initialization failed: ${error.message}`);
        // Don't throw the error - connection is still working
      }
    },

    initializeSmoothieChart() {
      // Create time series for count rate and dose rate
      this.countRateTimeSeries = new TimeSeries();
      this.doseRateTimeSeries = new TimeSeries();
      
      // Create the count rate chart
      this.countRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Create the dose rate chart
      this.doseRateChart = new SmoothieChart({
        responsive: true,
        millisPerPixel: 10,
        maxValueScale: 1.1,
        minValueScale: 1.1,
        tooltip: true,
        grid: {
          strokeStyle: 'rgba(119, 119, 119, 0.2)',
          fillStyle: 'rgba(0, 0, 0, 0.02)',
          lineWidth: 1,
          millisPerLine: 5000,
          verticalSections: 6
        },
        labels: {
          fillStyle: 'rgba(0, 0, 0, 0.6)',
          fontSize: 12
        }
      });
      
      // Add time series to charts
      this.countRateChart.addTimeSeries(this.countRateTimeSeries, {
        strokeStyle: 'rgba(0, 123, 255, 1)',
        fillStyle: 'rgba(0, 123, 255, 0.1)',
        lineWidth: 2
      });
      
      this.doseRateChart.addTimeSeries(this.doseRateTimeSeries, {
        strokeStyle: 'rgba(40, 167, 69, 1)',
        fillStyle: 'rgba(40, 167, 69, 0.1)',
        lineWidth: 2
      });
      
      // Start streaming to canvases
      this.$nextTick(() => {
        const countCanvas = document.getElementById('countRateChart');
        const doseCanvas = document.getElementById('doseRateChart');
        
        if (countCanvas && doseCanvas) {
          this.countRateChart.streamTo(countCanvas, this.updateInterval+500);
          this.doseRateChart.streamTo(doseCanvas, this.updateInterval+500);
          this.log('‚úÖ Real-time charts initialized');
        }
      });
    },

    destroySmoothieChart() {
      if (this.countRateChart) {
        this.countRateChart.stop();
        this.countRateChart = null;
      }
      if (this.doseRateChart) {
        this.doseRateChart.stop();
        this.doseRateChart = null;
      }
      this.countRateTimeSeries = null;
      this.doseRateTimeSeries = null;
    },

    async loadAlarmSettings() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Loading alarm settings...');
        this.alarmLimits = await this.device.getAlarmLimits();
        this.log(`‚úÖ Alarm limits loaded: CR L1/L2=${this.alarmLimits.l1_count_rate}/${this.alarmLimits.l2_count_rate} ${this.alarmLimits.count_unit}, DR L1/L2=${this.alarmLimits.l1_dose_rate}/${this.alarmLimits.l2_dose_rate} ¬µ${this.alarmLimits.dose_unit}/h`);
      } catch (error) {
        this.log(`‚ùå Failed to load alarm settings: ${error.message}`);
      }
    },

    async disconnect() {
      try {
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
          this.autoUpdateEnabled = false;
        }
        this.flushStorage(true);
        if (this.device) {
          await this.device.disconnect();
          this.log('‚úÖ Disconnected successfully');
        }
        
        // Destroy smoothie chart
        this.destroySmoothieChart();
        
        this.device = null;
        this.isConnected = false;
        this.connectionStatus = 'Disconnected';
        this.connectionStatusText = 'Not connected to device';
        
        // Clear device information
        this.deviceInfo = {
          firmwareVersion: null,
          serialNumber: null,
          connectionType: null,
          lastUpdate: null
        };
        
        // Clear alarm limits
        this.alarmLimits = null;
        window.deviceInfo = deviceInfo;
        
        // Reset current data
        this.currentData = {
          countRate: 0,
          doseRate: 0,
          countRateError: 0,
          doseRateError: 0
        };
        window.currentData = this.currentData;  
        
        this.resetStats();
        
      } catch (error) {
        this.log(`‚ùå Disconnect failed: ${error.message}`);
      }
    },

    toggleAutoUpdate() {
      if (this.autoUpdateEnabled) {
        // Stop auto-update
        if (this.updateTimer) {
          clearInterval(this.updateTimer);
          this.updateTimer = null;
        }
        this.autoUpdateEnabled = false;
        this.log('Auto-update stopped');
      } else {
        // Start auto-update
        this.autoUpdateEnabled = true;
        this.updateTimer = setInterval(() => {
          this.updateRatesData();
        }, this.updateInterval);
        this.storage.lastFlush = Date.now();
        this.log(`Auto-update started (${this.updateInterval/1000}s interval)`);
      }
    },

    async updateRatesData() {
      if (!this.isConnected || !this.device) return;
      try {
        const data = await this.device.data_buf();
        const now = new Date().getTime();
        // Process real-time data
        for (const record of data) {
          if (record instanceof RealTimeData) {
            // Debug logging - more detailed
            //this.log(`RealTimeData: CR=${record.count_rate.toFixed(2)} CPS, DR=${record.dose_rate.toFixed(6)} ¬µSv/h, flags=0x${record.flags.toString(16)}`);
            this.realTimeDataMessages++;
            if (this.realTimeDataMessages <= this.realTimeDataMessagesMax) {
              this.log(`RealTimeData: CR=${record.count_rate.toFixed(2)} CPS, DR=${record.dose_rate.toFixed(6)} ¬µSv/h, flags=0x${record.flags.toString(16)}`);
            }  
            if (this.realTimeDataMessages === this.realTimeDataMessagesMax) {
              this.log(`RealTimeData: stopping display after ${this.realTimeDataMessagesMax} messages`);
            }
            // Update current data
            this.currentData.countRate = record.count_rate;
            this.currentData.doseRate = record.dose_rate;
            this.currentData.countRateError = record.count_rate_err;
            this.currentData.doseRateError = record.dose_rate_err;
            
            // Add to smoothie chart
            if (this.countRateTimeSeries && this.doseRateTimeSeries) {
              this.countRateTimeSeries.append(now, record.count_rate);
              // Use original dose rate value (¬µSv/h) for dose rate chart
              this.doseRateTimeSeries.append(now, record.dose_rate);
            }
            
            // Add to rates series
            this.rates_series[0].data.push([now, record.count_rate]);
            this.rates_series[1].data.push([now, record.dose_rate]);

            window.dispatchEvent(new CustomEvent('update-cps', {
              detail: { message: record, cps: record.count_rate }
            }));
            
            // Update last update time
            this.deviceInfo.lastUpdate = new Date().toLocaleTimeString();
            
            // Keep only last 100 data points
            if (this.rates_series[0].data.length > 100) {
              this.rates_series[0].data = this.rates_series[0].data.slice(-100);
              this.rates_series[1].data = this.rates_series[1].data.slice(-100);
            }
            
            // Trigger chart update
            this.rates_series = [...this.rates_series];
            
            // ----- Min/Max update helper -----
            this.updateStats(record.count_rate, record.dose_rate);
            
            // ----- Storage (recording) helpers -----
            this.storeSample(now, record.count_rate, record.dose_rate);
            
            break; // Only process the first real-time record
          }
        }
        
      } catch (error) {
        this.log(`‚ùå Failed to update rates data: ${error.message}`);
      }
    },

    async updateSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Updating spectrum...');
        
        const spectrum = this.spectrum_accum ? 
          await this.device.spectrum_accum() : 
          await this.device.spectrum();
        
        this.spectrum_duration = spectrum.duration;
        this.spectrum_coef = [spectrum.a0, spectrum.a1, spectrum.a2];
        
        // Convert spectrum data to chart format
        const counts = spectrum.counts;
        const data = [];
        
        if (this.spectrum_energy) {
          // Energy scale
          for (let i = 0; i < counts.length; i++) {
            const energy = spectrum.channelToEnergy(i + 0.5);
            data.push([energy, counts[i]]);
          }
        } else {
          // Channel scale
          for (let i = 0; i < counts.length; i++) {
            data.push([i, counts[i]]);
          }
        }
        
        this.spectrum_series = [{
          name: 'Counts',
          data: data
        }];
        
        this.log(`‚úÖ Spectrum updated: ${spectrum.duration}s, ${spectrum.getTotalCounts()} total counts`);
        
      } catch (error) {
        this.log(`‚ùå Failed to update spectrum: ${error.message}`);
      }
    },

    async resetSpectrum() {
      if (!this.isConnected || !this.device) return;
      
      try {
        this.log('Resetting spectrum...');
        await this.device.spectrum_reset();
        this.log('‚úÖ Spectrum reset successfully');
        
        // Wait a moment then update
        setTimeout(() => {
          this.updateSpectrum();
        }, 1000);
        
      } catch (error) {
        this.log(`‚ùå Failed to reset spectrum: ${error.message}`);
      }
    },

    // ----- Min/Max update helper -----
    updateStats(cr, dr) {
      if (cr != null) {
        if (this.stats.countRate.min === null || cr < this.stats.countRate.min) this.stats.countRate.min = cr;
        if (this.stats.countRate.max === null || cr > this.stats.countRate.max) this.stats.countRate.max = cr;
      }
      if (dr != null) {
        if (this.stats.doseRate.min === null || dr < this.stats.doseRate.min) this.stats.doseRate.min = dr;
        if (this.stats.doseRate.max === null || dr > this.stats.doseRate.max) this.stats.doseRate.max = dr;
      }
    },
    resetStats() {
      this.stats.countRate.min = this.stats.countRate.max = null;
      this.stats.doseRate.min = this.stats.doseRate.max = null;
    },
    // ----- Storage (recording) helpers -----
    loadStoredSamples() {
      try {
        const raw = localStorage.getItem(this.storage.key);
        if (raw) {
          const obj = JSON.parse(raw);
          if (obj && Array.isArray(obj.samples)) {
            this.storage.totalSamples = obj.samples.length;
            this.storage.sizeBytes = raw.length;
          }
        }
      } catch (e) {
        this.log('‚ö†Ô∏è Failed to load stored samples: ' + e.message);
      }
    },
    getStoredObject() {
      try {
        const raw = localStorage.getItem(this.storage.key);
        if (raw) return JSON.parse(raw);
      } catch(_) {}
      return {version:1, samples:[]};
    },
    storeSample(ts, cr, dr) {
      if (!this.storage.enabled) return;
      this.storage.buffer.push([ts, Number(cr), Number(dr)]);
      const now = Date.now();
      if (this.storage.buffer.length >= this.storage.maxBufferSize || (now - this.storage.lastFlush) >= this.storage.flushInterval) {
        this.flushStorage();
      }
    },
    flushStorage(force) {
      if (!force && (!this.storage.buffer.length)) return;
      try {
        const obj = this.getStoredObject();
        // Append and prune if needed
        for (const row of this.storage.buffer) obj.samples.push(row);
        if (obj.samples.length > this.storage.maxSamples) {
          const remove = obj.samples.length - this.storage.maxSamples;
            obj.samples.splice(0, remove);
        }
        const raw = JSON.stringify(obj);
        localStorage.setItem(this.storage.key, raw);
        this.storage.totalSamples = obj.samples.length;
        this.storage.sizeBytes = raw.length;
        this.storage.buffer = [];
        this.storage.lastFlush = Date.now();
      } catch (e) {
        this.log('‚ùå Failed to flush storage: ' + e.message);
      }
    },
    toggleStorage() {
      this.storage.enabled = !this.storage.enabled;
      if (!this.storage.enabled) this.flushStorage(true);
      this.log(this.storage.enabled ? 'Recording resumed' : 'Recording paused');
    },
    clearStoredSamples() {
      try {
        localStorage.removeItem(this.storage.key);
        this.storage.totalSamples = 0;
        this.storage.sizeBytes = 0;
        this.storage.buffer = [];
        this.log('Stored samples cleared');
      } catch(e) { this.log('‚ùå Clear failed: ' + e.message); }
    },
    exportStoredSamples() {
      try {
        this.flushStorage(true);
        const obj = this.getStoredObject();
        const blob = new Blob([JSON.stringify(obj)], {type:'application/json'});
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'radiacode_realtime_' + new Date().toISOString().replace(/[:.]/g,'-') + '.json';
        document.body.appendChild(a); a.click(); a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1000);
        this.log('Exported stored samples');
      } catch(e) { this.log('‚ùå Export failed: ' + e.message); }
    },
    clearRatesData() {
      this.rates_series[0].data = [];
      this.rates_series[1].data = [];
      this.rates_series = [...this.rates_series];
      this.resetStats();
    }
  },
});
</script>
</body>
</html>
